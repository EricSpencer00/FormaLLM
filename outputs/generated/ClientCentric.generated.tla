---- MODULE ClientCentricIsolation ----
EXTENDS Integers, Sequences, FiniteSets, TLC

(***************************************************************************)
(* A database `State` is represented by keys with corresponding values     *)
(***************************************************************************)
CONSTANTS Keys, Values
InitValue == CHOOSE v : v \notin Values
State == [Keys -> Values \cup {InitValue}]

(***************************************************************************)
(* An `Operation` is a read or write of a key and value                    *)
(***************************************************************************)
Operation == [type: {"read", "write"}, key: Keys, value: Values]

(***************************************************************************)
(* Helpers representing Reads and Writes                                   *)
(***************************************************************************)
Read(k, v) == [type |-> "read", key |-> k, value |-> v]
Write(k, v) == [type |-> "write", key |-> k, value |-> v]

(***************************************************************************)
(* A `Transaction` is a total order of `Operation`s                        *)
(***************************************************************************)
Transaction == [ops: Seq(Operation), start: Nat, commit: Nat]

(***************************************************************************)
(* For simplicity we store start and commit in a lookup function           *)
(***************************************************************************)
TimeStamp == [transaction: Transaction |-> Nat]

(***************************************************************************)
(* "An execution e for a set of transactions T is a totally ordered set    *)
(* defined by the pair (Se,−−t \in T−→), where Se is the set of states     *)
(* generated by applying, starting from the system’s initial state, a       *)
(* permutation of all the transactions in T ."                             *)
(* resultState is the parentState of the next transaction, but not used in *)
(* the isolation definitions.                                              *)
(***************************************************************************)
ExecutionElem == [parentState: State, transaction: Transaction, resultState: State]

(***************************************************************************)
(* We represent an `Execution` as a sequence of `Transaction`s with their  *)
(* corresponding parent state. Note: This execution does therefore not     *)
(* contain the "final state" of the execution, since it is not a parent    *)
(* state of a transaction.                                                 *)
(***************************************************************************)
Execution == Seq(ExecutionElem)

(***************************************************************************)
(* "The parent state is the last state in the execution                    *)
(* Definition 1: s -T-> s' ≡ [(k,v) ∈ s ∧ (k,v) \notin s'] => k ∈ W_T /\   *)
(* w(k,v) ∈ Σ_T => (k,v) ∈ s. We refer to s as the parent state of T       *)
(* (denoted as sp,T ); to the transaction that generated s as Ts ; and to  *)
(* the set of keys in which s and s′ differ as ∆(s,s′)"                    *)
(***************************************************************************)
ParentState(s, T) == 
  LET W_T == {op.key : op \in Range(T.ops) | op.type = "write"}
  IN \A k \in Keys : 
    IF (k, s[k]) \in s /\ (k, s[k]) \notin s'
    THEN k \in W_T /\ Write(k, s[k]) \in Range(T.ops)
    ELSE (k, s[k]) \in s

(***************************************************************************)
(* w(k,v) -to-> r(k,v)                                                     *)
(* check reads and writes, implicit because of "write" check in ReadStates *)
(***************************************************************************)
ReadsWrites(s, T) == 
  \A op \in Range(T.ops) : 
    IF op.type = "read" 
    THEN op.value = s[op.key]
    ELSE op.type = "write"

(***************************************************************************)
(* state1 -*-> state2                                                      *)
(* Read states: from which states can the operation read it's value        *)
(***************************************************************************)
ReadStates(s1, s2, T) == 
  \A op \in Range(T.ops) : 
    IF op.type = "read" 
    THEN op.value = s1[op.key] \/ op.value = s2[op.key]
    ELSE op.type = "write"

(***************************************************************************)
(* s -*-> s_p: restrict the valid read states for the operations in T to   *)
(* be no later than sp                                                     *)
(***************************************************************************)
ReadStatesUpTo(s, sp, T) == 
  \A op \in Range(T.ops) : 
    IF op.type = "read" 
    THEN op.value = s[op.key] \/ op.value = sp[op.key]
    ELSE op.type = "write"

(***************************************************************************)
(* "By convention, write operations have read states too: for a write      *)
(* operation in T , they include all states in Se up to and including T ’s *)
(* parent state."                                                          *)
(***************************************************************************)
WriteReadStates(s, sp, T) == 
  \A op \in Range(T.ops) : 
    IF op.type = "write" 
    THEN op.value = s[op.key] \/ op.value = sp[op.key]
    ELSE op.type = "read"

(***************************************************************************)
(* A state `s` is complete for `T` in `e` if every operation in `T` can    *)
(* read from `s`                                                           *)
(***************************************************************************)
Complete(s, T, e) == 
  \A op \in Range(T.ops) : 
    op.value = s[op.key] \/ op.value \in {s'[op.key] : s' \in Range(e)}

(***************************************************************************)
(* readStatesForEmptyTransaction contains all previous states, to ensure   *)
(* that empty txns do not incorrectly invalidate the checked isolation     *)
(* level                                                                   *)
(***************************************************************************)
ReadStatesForEmptyTransaction(s, e) == 
  \A op \in Range(T.ops) : 
    op.value = s[op.key] \/ op.value \in {s'[op.key] : s' \in Range(e)}

(***************************************************************************)
(* "the write set of T comprises the keys that T updates: WT = {k|w(k, v)  *)
(* ∈ ΣT }. For simplicity of exposition, we assume that a transaction only *)
(* writes a key once."                                                     *)
(***************************************************************************)
WriteSet(T) == {op.key : op \in Range(T.ops) | op.type = "write"}

(***************************************************************************)
(* "Denoting the set of keys in which s and s′ differ as ∆(s, s′), we      *)
(* express this as NO-CONF_T (s) ≡ ∆(s, sp) ∩ WT = ∅"                     *)
(***************************************************************************)
NoConflict(s, sp, T) == 
  LET W_T == WriteSet(T)
  IN {k \in Keys : s[k] /= sp[k]} \cap W_T = {}

(***************************************************************************)
(* `t1` comes before `t2` in wall clock/oracle time                        *)
(***************************************************************************)
ComesBefore(t1, t2) == t1.commit < t2.start

(***************************************************************************)
(* Given system state and single transaction (seq of operations),          *)
(* determines new state                                                    *)
(***************************************************************************)
ApplyTransaction(s, T) == 
  [k \in Keys |-> IF k \in WriteSet(T) THEN [op \in Range(T.ops) | op.type = "write" /\ op.key = k].value ELSE s[k]]

(***************************************************************************)
(* Lists all possible permutations of executions given set of transactions *)
(***************************************************************************)
Executions(s, Ts) == 
  LET permutations == Permutations(Ts)
  IN [p \in permutations |-> [i \in 1..Len(p) |-> [parentState |-> IF i = 1 THEN s ELSE ApplyTransaction(s, p[i-1]), transaction |-> p[i]]]]

(***************************************************************************)
(* Helper: checks if specific execution satisfies given commit test        *)
(***************************************************************************)
SatisfiesCommitTest(T, e, commitTest) == 
  \A i \in 1..Len(e) : commitTest(T, e[i])

(***************************************************************************)
(* tests there exists an execution for `transactions`, that satisfies the  *)
(* isolation level given by `commitTest`                                   *)
(***************************************************************************)
SatisfiesIsolationLevel(s, transactions, commitTest) == 
  \E e \in Executions(s, transactions) : \A T \in transactions : SatisfiesCommitTest(T, e, commitTest)

(***************************************************************************)
(* "Definition 5 Given a set of transactions T and their read states,      *)
(* a storagesystem satisfies an isolation level I iff ∃e:∀t ∈ T :CTI(t,e)."*)
(***************************************************************************)
SatisfiesIsolationLevelI(s, T, I) == 
  \E e \in Executions(s, T) : \A t \in T : I(t, e)

(***************************************************************************)
(* Serializability commit test                                             *)
(***************************************************************************)
CT_SER(T, e) == 
  \A i \in 1..Len(e) : 
    IF e[i].transaction = T 
    THEN \A j \in 1..Len(e) : i /= j => ComesBefore(T, e[j].transaction) \/ ComesBefore(e[j].transaction, T)
    ELSE TRUE

(***************************************************************************)
(* Snapshot Isolation                                                      *)
(***************************************************************************)
CT_SI(T, e) == 
  \A i \in 1..Len(e) : 
    IF e[i].transaction = T 
    THEN \A j \in 1..Len(e) : i /= j => ComesBefore(T, e[j].transaction) \/ ComesBefore(e[j].transaction, T) \/ NoConflict(e[i].parentState, e[j].parentState, T)
    ELSE TRUE

(***************************************************************************)
(* Strict Serializability: ∀T ∈T:T <s T => s_T′ -*-> s_T.                  *)
(***************************************************************************)
CT_SSER(T, e) == 
  \A i \in 1..Len(e) : 
    IF e[i].transaction = T 
    THEN \A j \in 1..Len(e) : i /= j => ComesBefore(T, e[j].transaction) => e[i].parentState = e[j].parentState
    ELSE TRUE

(***************************************************************************)
(* Read Committed                                                          *)
(***************************************************************************)
CT_RC(T, e) == 
  \A i \in 1..Len(e) : 
    IF e[i].transaction = T 
    THEN \A j \in 1..Len(e) : i /= j => ComesBefore(T, e[j].transaction) \/ ComesBefore(e[j].transaction, T) \/ NoConflict(e[i].parentState, e[j].parentState, T) \/ ReadStates(e[i].parentState, e[j].parentState, T)
    ELSE TRUE

(***************************************************************************)
(* Read Uncommitted                                                        *)
(***************************************************************************)
CT_RU(T, e) == 
  \A i \in 1..Len(e) : 
    IF e[i].transaction = T 
    THEN \A j \in 1..Len(e) : i /= j => ComesBefore(T, e[j].transaction) \/ ComesBefore(e[j].transaction, T) \/ NoConflict(e[i].parentState, e[j].parentState, T) \/ ReadStates(e[i].parentState, e[j].parentState, T) \/ ReadStatesUpTo(e[i].parentState, e[j].parentState, T)
    ELSE TRUE

(***************************************************************************)
(* Check types in derived specification                                    *)
(***************************************************************************)
TypeOK == 
  /\ InitValue \in Values
  /\ \A s \in State : s \in [Keys -> Values \cup {InitValue}]
  /\ \A op \in Operation : op \in [type: {"read", "write"}, key: Keys, value: Values]
  /\ \A T \in Transaction : T \in [ops: Seq(Operation), start: Nat, commit: Nat]
  /\ \A ts \in TimeStamp : ts \in [transaction: Transaction |-> Nat]
  /\ \A ee \in ExecutionElem : ee \in [parentState: State, transaction: Transaction, resultState: State]
  /\ \A e \in Execution : e \in Seq(ExecutionElem)

(***************************************************************************)
(* PrintT(State)                                                           *)
(***************************************************************************)
PrintState(s) == PrintT(s)

====