A filter applied on each permutation
generated by [S -> T]
The given StateGraph is actually a graph
The violating states are vertices in the state graph.
A FIFO containing all unexplored states. A simple
set provides no order, but TLC should explore the
StateGraph in either BFS (or DFS => LIFO).
Note that S is initialized with each
possible permutation of the initial states
here because there is no defined order
of initial states.
A set of already explored states.
The state currently being explored in scsr
The set of state's successor states
Counter
A path from some initial state ending in a
state in violation.
A sequence of pairs such that a pair is a
sequence <<predecessor, successors>>.
Bug in thesis:
state := Head(S);
state is now fully explored,
thus exclude it from any
further exploration if graph
exploration visits it again
due to a cycle.
Terminate model checking
Assert that all initial states have been explored.
Assign the first element of
S to state. state is
what is currently being checked.
Remove state from S.
For each unexplored successor 'succ' do:
Iff there exists no successor besides
the self-loop, the system has reached
a deadlock state.
Exclude succ in this while loop.
Mark successor globally visited.
Append succ to T and add it
to the list of unexplored states.
Check state for violation of a
safety property (simplified
to a check of set membership.
Terminate model checking
No states left unexplored and no ViolationState given.
BEGIN TRANSLATION
END TRANSLATION
**************************************************************************)
Convertes the given Sequence seq into a Set of all the                  *)
Sequence's elements. In other words, the image of the function          *)
that seq is.                                                            *)
**************************************************************************)
**************************************************************************)
Returns a Set of those permutations created out of the elements of Set  *)
set which satisfy Filter.                                               *)
**************************************************************************)
**************************************************************************)
Returns a Set of all possible permutations with distinct elements     *)
created out of the elements of Set set. All elements of set occur in    *)
in the sequence.                                                        *)
**************************************************************************)
**************************************************************************)
A (state) graph G is a directed cyclic graph.                           *)
*)
A graph G is represented by a record with 'states' and 'actions'        *)
components, where G.states is the set of states and G.actions[s] is the *)
set of transitions of s -- that is, all states t such that there is an  *)
action (arc) from s to t.                                               *)
**************************************************************************)
**************************************************************************)
A set of all permutations of the initial states of G.                    *)
**************************************************************************)
**************************************************************************)
A Set of successor states state.                                        *)
**************************************************************************)
**************************************************************************)
The predecessor of v in a forest t is the first element of the pair     *)
<<predecessor, successor>> nested in a sequence of pairs. In an actual  *)
implementation such as TLC, pair[1] is rather an index into t than      *)
an id of an actual state.                                               *)
**************************************************************************)
The PlusCal code of the model checker algorithm
--fair algorithm ModelChecker {
variables
A FIFO containing all unexplored states. A simple
set provides no order, but TLC should explore the
StateGraph in either BFS (or DFS => LIFO).
Note that S is initialized with each
possible permutation of the initial states
here because there is no defined order
of initial states.
S \in SetOfAllPermutationsOfInitials(StateGraph),
A set of already explored states.
C = {},
The state currently being explored in scsr
state = null,
The set of state's successor states
successors = {},
Counter
i = 1,
A path from some initial state ending in a
state in violation.
counterexample = <<>>,
A sequence of pairs such that a pair is a
sequence <<predecessor, successors>>.
T = <<>>;
{
Check initial states for violations. We could
be clever and check the initial states as part
of the second while loop. However, we then
either check all states twice or add unchecked
states to S. *)
Explores all successor states
until no new successors are found
or a violation has been detected. *)
Model Checking terminated without finding
a violation. *)
Create a counterexample, that is a path
from some initial state to a state in
ViolationStates. In the Java implementation
of TLC, the path is a path of fingerprints.
Thus, a second, guided state exploration
resolves fingerprints to actual states. *)
Global variables *)
Allow infinite stuttering to prevent deadlock on termination. *)