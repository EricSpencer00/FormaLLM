\* BEGIN TRANSLATION
\* END TRANSLATION
\* , Inv, TypeOK, DomainPartitions, RelSorted, UV, PermsOf
\* Modification History
\* Last modified Fri May 03 16:28:36 PDT 2019 by lamport
\* Created Mon Jun 27 08:20:07 PDT 2016 by lamport
(***************************************************************************)
(* This module contains an abstract version of the Quicksort algorithm.    *)
(* If you are not already familiar with that algorithm, you should look it *)
(* up on the Web and understand how it works--including what the partition *)
(* procedure does, without worrying about how it does it.  The version     *)
(* presented here does not specify a partition procedure, but chooses in a *)
(* single step an arbitrary value that is the result that any partition    *)
(* procedure may produce.                                                  *)
(*                                                                         *)
(* The module also has a structured informal proof of Quicksort's partial  *)
(* correctness property--namely, that if it terminates, it produces a      *)
(* sorted permutation of the original sequence.  As described in the note  *)
(* "Proving Safety Properties", the proof uses the TLAPS proof system to   *)
(* check the decomposition of the proof into substeps, and to check some   *)
(* of the substeps whose proofs are trivial.                               *)
(*                                                                         *)
(* The version of Quicksort described here sorts a finite sequence of      *)
(* integers.  It is one of the examples in Section 7.3 of "Proving Safety  *)
(* Properties", which is at                                                *)
(*                                                                         *)
(*    http://lamport.azurewebsites.net/tla/proving-safety.pdf              *)
(***************************************************************************)
(*************************************************************************)
(* This statement imports some standard modules, including ones used by  *)
(* the TLAPS proof system.                                               *)
(*************************************************************************)
(***************************************************************************)
(* To aid in model checking the spec, we assume that the sequence to be    *)
(* sorted are elements of a set Values of integers.                        *)
(***************************************************************************)
(***************************************************************************)
(* We define PermsOf(s) to be the set of permutations of a sequence s of   *)
(* integers.  In TLA+, a sequence is a function whose domain is the set    *)
(* 1..Len(s).  A permutation of s is the composition of s with a           *)
(* permutation of its domain.  It is defined as follows, where:            *)
(*                                                                         *)
(*  - Automorphisms(S) is the set of all permutations of S, if S is a      *)
(*    finite set--that is all functions f from S to S such that every      *)
(*    element y of S is the image of some element of S under f.            *)
(*                                                                         *)
(*  - f ** g  is defined to be the composition of the functions f and g.   *)
(*                                                                         *)
(* In TLA+, DOMAIN f is the domain of a function f.                        *)
(***************************************************************************)
(**************************************************************************)
(* We define Max(S) and Min(S) to be the maximum and minimum,             *)
(* respectively, of a finite, non-empty set S of integers.                *)
(**************************************************************************)
(***************************************************************************)
(* The operator Partitions is defined so that if I is an interval that's a *)
(* subset of 1..Len(s) and p \in Min(I) ..  Max(I)-1, the Partitions(I, p, *)
(* seq) is the set of all new values of sequence seq that a partition      *)
(* procedure is allowed to produce for the subinterval I using the pivot   *)
(* index p.  That is, it's the set of all permutations of seq that leaves  *)
(* seq[i] unchanged if i is not in I and permutes the values of seq[i] for *)
(* i in I so that the values for i =< p are less than or equal to the      *)
(* values for i > p.                                                       *)
(***************************************************************************)
(***************************************************************************)
(* Our algorithm has three variables:                                      *)
(*                                                                         *)
(*    seq  : The array to be sorted.                                       *)
(*                                                                         *)
(*    seq0 : Holds the initial value of seq, for checking the result.      *)
(*                                                                         *)
(*    U : A set of intervals that are subsets of 1..Len(seq0), an interval *)
(*        being a nonempty set I of integers that equals Min(I)..Max(I).   *)
(*        Initially, U equals the set containing just the single interval  *)
(*        consisting of the entire set 1..Len(seq0).                       *)
(*                                                                         *)
(* The algorithm repeatedly does the following:                            *)
(*                                                                         *)
(*    - Chose an arbitrary interval I in U.                                *)
(*                                                                         *)
(*    - If I consists of a single element, remove I from U.                *)
(*                                                                         *)
(*    - Otherwise:                                                         *)
(*        - Let I1 be an initial interval of I and I2 be the rest of I.    *)
(*        - Let newseq be an array that's the same as seq except that the  *)
(*          elements seq[x] with x in I are permuted so that               *)
(*          newseq[y] =< newseq[z] for any y in I1 and z in I2.            *)
(*        - Set seq to newseq.                                             *)
(*        - Remove I from U and add I1 and I2 to U.                        *)
(*                                                                         *)
(* It stops when U is empty.  Below is the algorithm written in PlusCal.   *)
(***************************************************************************)
(***************************************************************************
--fair algorithm Quicksort {
  variables  seq \in Seq(Values) \ {<< >>}, seq0 = seq,  U = {1..Len(seq)};
  { a: while (U # {}) 
        { with (I \in U) 
            { if (Cardinality(I) = 1) 
                { U := U \ {I} } 
              else 
                { with (p \in Min(I) .. (Max(I)-1),
                        I1 = Min(I)..p,
                        I2 = (p+1)..Max(I),
                        newseq \in Partitions(I, p, seq))
                    { seq := newseq ;
                      U := (U \ {I}) \cup {I1, I2} }      }  }  }  }  }

****************************************************************************)
(***************************************************************************)
(* Below is the TLA+ translation of the PlusCal code.                      *)
(***************************************************************************)
(* Global variables *)
(* Allow infinite stuttering to prevent deadlock on termination. *)
(***************************************************************************)
(* PCorrect is the postcondition invariant that the algorithm should       *)
(* satisfy.  You can use TLC to check this for a model in which Seq(S) is  *)
(* redefined to equal the set of sequences of at elements in S with length *)
(* at most 4.  A little thought shows that it then suffices to let Values  *)
(* be a set of 4 integers.                                                 *)
(***************************************************************************)
(***************************************************************************)
(* Below are some definitions leading up to the definition of the          *)
(* inductive invariant Inv used to prove the postcondition PCorrect.  The  *)
(* partial TLA+ proof follows.  As explained in "Proving Safety            *)
(* Properties", you can use TLC to check the level-<1> proof steps.  TLC   *)
(* can do those checks on a model in which all sequences have length at    *)
(* most 3.                                                                 *)
(***************************************************************************)
(*********************************************************************)
(* Follows easily from definition of UV, seq0 = seq, and seq a       *)
(* non-empty sequence.                                               *)
(*********************************************************************)
(*********************************************************************)
(* Because seq0 = seq and seq a non-empty sequence imply Len(seq0) a *)
(* positive natural number.                                          *)
(*********************************************************************)
(*********************************************************************)
(* This is obvious because the identity function is a permutation of *)
(* 1..Len(seq).                                                      *)
(*********************************************************************)
(*******************************************************************)
(* a!2!2!1(I) is the formula following `\E I \in U:' in the        *)
(* definition of a.                                                *)
(*******************************************************************)
(***************************************************************)
(* The action removes a singleton set {j} from U, which adds j *)
(* to the set {{i} : i \in 1..Len(seq) \ UNION U}, thereby     *)
(* keeping it in UV.                                           *)
(***************************************************************)
(*****************************************************************)
(* Since I is in U, invariant Inv implies I is a non-empty       *)
(* subinterval of 1..Len(seq), and the <4>4 case assumption      *)
(* implies Min(I) < Max(I).  Therefore I1(p) and I2(p) are       *)
(* nonempty subintervals of 1..Len(seq).  It's clear from the    *)
(* definitions of I1(p) and I2(p) that they are disjoint sets    *)
(* whose union is I.  The final conjunct follows from the        *)
(* definition of Partitions(I, p, seq).                          *)
(*****************************************************************)
(*****************************************************************)
(* By <5>2 and definition of Partitions.                         *)
(*****************************************************************)
(*****************************************************************)
(* By <5>2 and <5>3, since the action removes I from U and adds  *)
(* I1(p) and I2(p) to it.                                        *)
(*****************************************************************)
(*****************************************************************)
(* By <5>2, <5>3, and definition of UV, since Len(seq) =         *)
(* Len(seq').                                                    *)
(*****************************************************************)
(***************************************************************)
(* By <5>2 and definitions of Partitions and PermsOf, since    *)
(* seq a non-empty sequence of Values implies PermsOf(seq) is  *)
(* one too.                                                    *)
(***************************************************************)
(***************************************************************)
(* By <5>2 and <5>3.                                           *)
(***************************************************************)
(***************************************************************)
(* If J and K are in UV, then this follows from Inv.  If one   *)
(* of them is in UV and the other equals I1(p) or I2(p), it    *)
(* follows because I1(p) \cup I2(p) = I and I is disjoint from *)
(* other elements of UV.  If J and K are I1(p) and I2(p), then *)
(* it follows from the definitions of I1(p) and I2(p).  By     *)
(* <5>6, this covers all possibilities.                        *)
(***************************************************************)
(*****************************************************************)
(* By <5>2 and definition of Partitions, seq' \in PermsOf(seq),  *)
(* and seq \in PermsOf(seq0) implies PermsOf(seq) =              *)
(* PermsOf(seq0).                                                *)
(*****************************************************************)
(***************************************************************)
(* IF I_1 and J are in UV, then this follows from Inv.  If one *)
(* of them is in UV and the other equals I1(p) or I2(p), it    *)
(* follows from Inv because RelSorted(I, K) and RelSorted(K,   *)
(* I) holds for all K in UV and I1(p) and I2(p) are subsets of *)
(* I.  If I_1 and J are I1(p) and I2(p), then it follows from  *)
(* the definitions of I1 and I2.  By <5>6, this covers all     *)
(* possibilities.                                              *)
(***************************************************************)
(*********************************************************************)
(* By seq \in PermsOf(seq0), seq a non-empty sequence, and           *)
(* definition of PermsOf.                                            *)
(*********************************************************************)
