BEGIN TRANSLATION
END TRANSLATION
Modification History
Last modified Fri May 22 09:20:18 CEST 2020 by merz
Last modified Fri Jul 15 11:31:15 PDT 2011 by lamport
The following is used to check theorem Liveness
**************************************************************************)
This is a specification of a variant of the classic Paxos consensus     *)
algorithm described in                                                  *)
*)
AUTHOR = "Leslie Lamport",                                           *)
TITLE = "The Part-Time Parliament",                                  *)
journal = ACM Transactions on Computing Systems,                     *)
volume = 16,                                                         *)
Number = 2,                                                          *)
Month = may,                                                         *)
Year = 1998,                                                         *)
pages = "133--169"                                                   *)
*)
This algorithm was also described without proof in Brian Oki's Ph.D.    *)
thesis.                                                                 *)
*)
It describes the actions that can be performed by leaders, but does not *)
introduce explicit leader processes.  More precisely, the specification *)
is written as if there were a separate leader for each ballot.          *)
*)
This variant of the classic Paxos algorithm is an abstraction of an     *)
algorithm that is used in                                               *)
*)
AUTHOR = "Leslie Lamport and Dahlia Malkhi and Lidong Zhou ",        *)
TITLE = "Vertical Paxos and Primary-Backup Replication",             *)
Conference = "Proceedings of PODC 2009",                             *)
editor    = {Srikanta Tirthapura and Lorenzo Alvisi},                *)
publisher = {ACM},                                                   *)
YEAR = 2009,                                                         *)
PAGES = "312--313"                                                   *)
*)
and in                                                                  *)
*)
Cheap paxos                                                          *)
United States Patent 7249280                                         *)
Inventors: Lamport, Leslie B.                                        *)
Massa, Michael T.                                         *)
Filing Date:06/18/2004                                               *)
*)
In the classic Paxos algorithm, the leader sends a phase 2a message for *)
a ballot b and value v that instructs acceptors to vote for v in ballot *)
b.  In terms of implementing the voting algorithm of module VoteProof,  *)
that 2a message serves two functions:                                   *)
*)
- It asserts that value v is safe at ballot b, so the acceptor        *)
can vote for it without violating invariant VInv2                   *)
*)
- It tells the acceptors which single safe value they can vote        *)
for in ballot b, so they can vote for that value without            *)
violating VInv3.                                                    *)
*)
The variant of the algorithm we specify here introduces phase 1c        *)
messages that perform the first function.  The phase 2a message serves  *)
only the first function, being sent only if a 1c message had been sent  *)
for the value.                                                          *)
*)
This variant of the algorithm is useful when reconfiguration is         *)
performed by using different sets of acceptors for different ballots.   *)
The leader propagates knowledge of what values are safe at ballot b so  *)
that the acceptors in the current configuration are no longer needed to *)
determine that information.  If the ballot b leader determines that all *)
values are safe at b, then it sends a 1c message for every value and    *)
sends a phase 2a message only when it has a value to propose.  The      *)
presence of the 1c messages removes dependency on the acceptors of      *)
ballots numbered b or lower for progress.  (If the leader determines    *)
that only a single value is safe at b, then it sends the 1c and 2a      *)
messages together.)                                                     *)
*)
In the algorithm described here, we do not include reconfiguration.     *)
Therefore, the sending of a 1c message serves only as a precondition    *)
for the sending of a 2a message with that value.                        *)
*)
Classic Paxos and its variants maintain consensus in the presence of    *)
omission faults--faults in which a process fails to perform some        *)
enabled action or a message that is sent fails to be received.  The     *)
safety specification, which is given by the PlusCal code, does not      *)
require that any action need ever be performed.  A process need not     *)
execute an enabled action.  Receipt of a message is modeled by a        *)
process performing the action enabled by that message having been sent, *)
so message loss is also represented by a process not performing an      *)
enabled action.  Thus, failures are never mentioned in the description  *)
of the algorithm.                                                       *)
**************************************************************************)
**************************************************************************)
The constant parameters and the set Ballots are the same as in the      *)
voting algorithm.                                                       *)
**************************************************************************)
**************************************************************************)
We are going to have a leader process for each ballot and an acceptor   *)
process for each acceptor.  So we can use the ballot numbers and the    *)
acceptors themselves as the identifiers for these processes, we assume  *)
that the set of ballots and the set of acceptors are disjoint.  For     *)
good measure, we also assume that -1 is not an acceptor, although that  *)
is probably not necessary.                                              *)
**************************************************************************)
**************************************************************************)
We define None to be an unspecified value that is not in the set Value. *)
**************************************************************************)
**************************************************************************)
This is a message-passing algorithm, so we begin by defining the set    *)
Message of all possible messages.  The messages are explained below     *)
with the actions that send them.  A message m with m.type = "1a" is     *)
called a 1a message, and similarly for the other message types.         *)
**************************************************************************)
**************************************************************************)
The algorithm is easiest to understand in terms of the set msgs of all  *)
messages that have ever been sent.  A more accurate model would use one *)
or more variables to represent the messages actually in transit, and it *)
would include actions representing message loss and duplication as well *)
as message receipt.                                                     *)
*)
In the current spec, there is no need to model message loss explicitly. *)
The safety part of the spec says only what messages may be received and *)
does not assert that any message actually is received.  Thus, there is  *)
no difference between a lost message and one that is never received.    *)
The liveness property of the spec will make it clear what messages must *)
be received (and hence either not lost or successfully retransmitted if *)
lost) to guarantee progress.                                            *)
*)
Another advantage of maintaining the set of all messages that have ever *)
been sent is that it allows us to define the state function `votes'     *)
that implements the variable of the same name in the voting algorithm   *)
without having to introduce a history variable.                         *)
**************************************************************************)
In addition to the variable msgs, the algorithm uses four variables
whose values are arrays indexed by acceptor, where for any acceptor
`a':
maxBal[a]  The largest ballot number in which `a' has participated
maxVBal[a] The largest ballot number in which a has voted, or -1
if it has never voted.
maxVVal[a] If `a' has voted, then this is the value it voted for in
ballot maxVBal; otherwise it equals None.
As in the voting algorithm, an execution of the algorithm consists of an
execution of zero or more ballots.  Different ballots may be in progress
concurrently, and ballots may not complete (and need not even start).
A ballot b consists of the following actions (which need not all occur
in the indicated order).
Phase1a : The leader sends a 1a message for ballot b
Phase1b : If maxBal[a] < b, an acceptor `a' responds to the 1a message by
setting maxBal[a] to b and sending a 1b message to the leader
containing the values of maxVBal[a] and maxVVal[a].
Phase1c : When the leader has received ballot-b 1b messages from a
quorum, it determines some set of values that are safe
at b and sends 1c messages for them.
Phase2a : The leader sends a 2a message for some value for which it has
already sent a ballot-b 1c message.
Phase2b : Upon receipt of the 2a message, if maxBal[a] =< b, an
acceptor `a' sets maxBal[a] and maxVBal[a] to b, sets
maxVVal[a] to the value in the 2a message, and votes for
that value in ballot b by sending the appropriate 2b
message.
Here is the PlusCal code for the algorithm, which we call PCon.
--algorithm PCon {
variables maxBal  = [a \in Acceptor |-> -1] ,
maxVBal = [a \in Acceptor |-> -1] ,
maxVVal = [a \in Acceptor |-> None] ,
msgs = {}
define {
sentMsgs(t, b) == {m \in msgs : (m.type = t) /\ (m.bal = b)}
**********************************************************************)
We define ShowsSafeAt so that ShowsSafeAt(Q, b, v) is true for a    *)
quorum Q iff msgs contain ballot-b 1b messages from the acceptors   *)
in Q showing that v is safe at b.                                   *)
**********************************************************************)
************************************************************************)
The following two macros send a message and a set of messages,        *)
respectively.  These macros are so simple that they're hardly worth   *)
introducing, but they do make the processes a little easier to read.  *)
************************************************************************)
************************************************************************)
The Actions                             *)
As before, we describe each action as a macro.                        *)
*)
The leader for process `self' can execute a Phase1a() action, which   *)
sends the ballot `self' 1a message.                                   *)
************************************************************************)
************************************************************************)
Acceptor `self' can perform a Phase1b(b) action, which is enabled iff *)
b > maxBal[self].  The action sets maxBal[self] to b and sends a      *)
phase 1b message to the leader containing the values of maxVBal[self] *)
and maxVVal[self].                                                    *)
************************************************************************)
************************************************************************)
The ballot `self' leader can perform a Phase1c(S) action, which sends *)
a set S of 1c messages indicating that the value in the val field of  *)
each of them is safe at ballot b.  In practice, S will either contain *)
a single message, or else will have a message for each possible       *)
value, indicating that all values are safe.  In the first case, the   *)
leader will immediately send a 2a message with the value contained in *)
that single message.  (Both logical messages will be sent in the same *)
physical message.) In the latter case, the leader is informing the    *)
acceptors that all values are safe.  (All those logical messages      *)
will, of course, be encoded in a single physical message.)            *)
************************************************************************)
************************************************************************)
The ballot `self' leader can perform a Phase2a(v) action, sending a   *)
2a message for value v, if it has not already sent a 2a message (for  *)
this ballot) and it has sent a ballot `self' 1c message with val      *)
field v.                                                              *)
************************************************************************)
************************************************************************)
The Phase2b(b) action is executed by acceptor `self' in response to a *)
ballot-b 2a message.  Note this action can be executed multiple times *)
by the acceptor, but after the first one, all subsequent executions   *)
are stuttering steps that do not change the value of any variable.    *)
************************************************************************)
************************************************************************)
An acceptor performs the body of its `while' loop as a single atomic  *)
action by nondeterministically choosing a ballot in which its Phase1b *)
or Phase2b action is enabled and executing that enabled action.  If   *)
no such action is enabled, the acceptor does nothing.                 *)
************************************************************************)
************************************************************************)
The leader of a ballot nondeterministically chooses one of its        *)
actions that is enabled (and the argument for which it is enabled)    *)
and performs it atomically.  It does nothing if none of its actions   *)
is enabled.                                                           *)
************************************************************************)
define statement *)
Global variables *)
**************************************************************************)
We now rewrite the next-state relation in a way that makes it easier to *)
use in a proof.  We start by defining the formulas representing the     *)
individual actions.  We then use them to define the formula TLANext,    *)
which is the next-state relation we would have written had we specified *)
the algorithm directly in TLA+ rather than in PlusCal.                  *)
**************************************************************************)
**************************************************************************)
The following theorem specifies the relation between the next-state     *)
relation Next obtained by translating the PlusCal code and the          *)
next-state relation TLANext.                                            *)
**************************************************************************)
**************************************************************************)
The type invariant.                                                     *)
**************************************************************************)
**************************************************************************)
Here is the definition of the state-function `chosen' that implements   *)
the state-function of the same name in the voting algorithm.            *)
**************************************************************************)
**************************************************************************)
We now define the refinement mapping under which this algorithm         *)
implements the specification in module Voting.                          *)
**************************************************************************)
**************************************************************************)
As we observed, votes are registered by sending phase 2b messages.  So  *)
the array `votes' describing the votes cast by the acceptors is defined *)
as follows.                                                             *)
**************************************************************************)
**************************************************************************)
We now instantiate module Voting, substituting:                         *)
*)
- The constants Value, Acceptor, and Quorum declared in this module    *)
for the corresponding constants of that module Voting.               *)
*)
- The variable maxBal and the defined state function `votes' for the   *)
correspondingly-named variables of module Voting.                    *)
**************************************************************************)
**************************************************************************)
We now define PInv to be what I believe to be an inductive invariant    *)
and assert the theorems for proving that this algorithm implements the  *)
voting algorithm under the refinement mapping specified by the INSTANCE *)
statement.  Whether PInv really is an inductive invariant will be       *)
determined only by a rigorous proof.                                    *)
**************************************************************************)
**************************************************************************)
The following theorem is interesting in its own right.  It essentially  *)
asserts the correctness of the definition of ShowsSafeAt.               *)
**************************************************************************)
**************************************************************************)
The following result shows that our definition of `chosen' is the       *)
correct one, because it implements the state-function `chosen' of the   *)
voting algorithm.                                                       *)
**************************************************************************)
**************************************************************************)
The four theorems above have been checked by TLC for a model with 3     *)
acceptors, 2 values, and 3 ballot numbers.  Theorem PT1 was checked as  *)
an invariant, therefore checking only that it is true for all reachable *)
states.  This model is large enough that it would most likely have      *)
revealed any "coding" errors in the algorithm.  We believe that the     *)
algorithm is well-enough understood that it is unlikely to contain any  *)
fundamental errors.                                                     *)
**************************************************************************)
**************************************************************************)
Liveness                                  *)
*)
The liveness property satisfied by PCon (and classic Paxos) is:         *)
*)
If there is some ballot b and quorum Q such that                        *)
*)
1. No phase 1a messages (a) have been or (b) ever will be sent for any *)
ballot number greater than b.                                       *)
*)
2. The ballot b leader eventually sends a phase 1a message for ballot  *)
b.                                                                  *)
*)
3. Each acceptor in Q eventually responds to ballot b messages sent    *)
by the ballot b leader--which implies that it eventually receives   *)
those messages.                                                     *)
*)
4. The ballot b leader eventually executes its Phase2a action for      *)
ballot b if it can.                                                 *)
*)
then some value is eventually chosen.                                   *)
*)
Note that Phase2a(b) is enabled if msgs contains a ballot b phase 1b    *)
message from every acceptor in Q.  Hence, 4 implies that if the leader  *)
eventually receives those messages, then it must perform its Phase2a(b) *)
action.  (It might perform that action before it receives those         *)
messages if it has received phase 1b messages from all the acceptors in *)
a different quorum.)                                                    *)
**************************************************************************)
********************************************************)
Assumption 1a.                                        *)
********************************************************)
********************************************************)
Assumption 1b.                                        *)
********************************************************)
********************************************************)
Assumption 2.                                         *)
********************************************************)
********************************************************)
Assumption 4.                                         *)
********************************************************)
********************************************************)
Assumption 3.                                         *)
********************************************************)