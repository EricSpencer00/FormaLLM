\* TODO InitValue could be bottom (_|_)
\* TLA+ specifications of Client Centric Isolation Specification by Crooks et al: https://dl.acm.org/doi/10.1145/3087801.3087802
\* TLA+ specifications by Tim Soethout (tim.soethout@ing.com) et al: Automated Validation of State-Based Client-Centric Isolation with TLA+: https://doi.org/10.1007/978-3-030-67220-1_4
\* A database `State` is represented by keys with corresponding values
\* An `Operation` is a read or write of a key and value
\* Helpers representing Reads and Writes
\* A `Transaction` is a total order of `Operation`s
\* Transaction == [ops: Seq(Operation), start: TimeStamp, commit: TimeStamp]
\* For simplicity we store start and commit in a lookup function
\* "An execution e for a set of transactions
\* T is a totally ordered set defined by the pair (Se,−−t \in T−→),
\* where Se is the set of states generated by applying,
\* starting from the system’s initial state, a permutation of all the transactions in T ."
\* resultState is the parentState of the next transaction, but not used in the isolation definitions.
\* ExecutionElem == [parentState: State, transaction: Transaction, resultState: State]
\* We represent an `Execution` as a sequence of `Transaction`s with their corresponding parent state.
\* Note: This execution does therefore not contain the "final state" of the execution, since it is not a parent state of a transaction.
\* Seq
\* Set
\* "The parent state is the last state in the execution
\* Definition 1: s -T-> s' ≡ [(k,v) ∈ s ∧ (k,v) \notin s'] => k ∈ W_T /\ w(k,v) ∈ Σ_T => (k,v) ∈ s.
\* We refer to s as the parent state of T (denoted as sp,T ); to the
\* transaction that generated s as Ts ; and to the set of keys in which
\* s and s′ differ as ∆(s,s′)"
\* w(k,v) -to-> r(k,v)
\* check reads and writes, implicit because of "write" check in ReadStates
\* state1 -*-> state2
\* Read states: from which states can the operation read it's value
\* s -*-> s_p: restrict the valid read states for the operations in T to be no later than sp
\* (k,v) \in s
\* w(k,v)-to->r(k,v)
\* "By convention, write operations have read states too: for a write operation in T , they include all states in Se up to and including T ’s parent state."
\* A state `s` is complete for `T` in `e` if every operation in `T` can read from `s`
\* readStatesForEmptyTransaction contains all previous states, to ensure that empty txns do not incorrectly invalidate the checked isolation level
\* "the write set of T comprises the keys that T updates: WT = {k|w(k, v) ∈ ΣT }.
\* For simplicity of exposition, we assume that a transaction only writes a key once."
\* "Denoting the set of keys in which s and s′ differ as ∆(s, s′), we express this as NO-CONF_T (s) ≡ ∆(s, sp) ∩ WT = ∅"
\* `t1` comes before `t2` in wall clock/oracle time
\* Given system state and single transaction (seq of operations), determines new state
\* Lists all possible permutations of executions given set of transactions
\* All possible permutations
\*      initialState == [k \in Keys |-> InitValue] \* makes it level-1 therefore pass it in
\*                                store ExecutionElem in accumulator
\*                                         calculate next state
\*              recover ExecutionElems
\* Helper: checks if specific execution satisfies given commit test
\* tests there exists an execution for `transactions`, that satisfies the isolation level given by `commitTest`
\* "Definition 5 Given a set of transactions T and their read states,
\* a storagesystem satisfies an isolation level I iff ∃e:∀t ∈ T :CTI(t,e)."
\* PrintT(<<"try execution:",execution>>) =>
\* Serializability commit test
\*SerializabilityDebug(initialState, transactions) ==
\*  \* if no executions satisfy commit test, print all executions
\*  \/ (~\E execution \in executions(initialState, transactions): \A transaction \in transactions:
\*       CT_SER(transaction, execution)) => \A execution \in executions(initialState, transactions): PrintT(<<"Execution not Serializable:",execution>>)
\*  \* fall back to normal check
\*  \/ \E execution \in executions(initialState, transactions): \A transaction \in transactions: CT_SER(transaction, execution)
\* Snapshot Isolation
\* Strict Serializability: ∀T ∈T:T <s T => s_T′ -*-> s_T.
\* For now inline `satisfyIsolationLevel` instead of `satisfyIsolationLevel(transactions, CT_SSER(timestamps)) because partial functions are not supported/hard`
\* Read Committed
\* Read Uncommitted
\* Check types in derived specification
\*  /\ InitValue \in Values
\*  /\ PrintT(State)
